"""This module contains some helper functions."""

import importlib
import os
import traceback

from .. import _tgbot_cache
from . import LOGS

__all__ = (
    "load_modules",
    "is_dangerous",
    "TempCache",
)

# Why not...
class TempCache:
    """Caching logic that can handle different data types."""
    def __init__(self, cache_dict=None):
        """Initialize with an external dictionary (or create a new one if None)."""
        self.cache = cache_dict if cache_dict is not None else {}

    def set(self, key, value):
        """Set a value in the cache."""
        self.cache[key] = value

    def get(self, key, default=None):
        """Retrieve a value from the cache."""
        return self.cache.get(key, default)

    def delete(self, key):
        """Delete a key from the cache."""
        self.cache.pop(key, None)

    def list_add(self, key, item):
        """Add an item to a list in the cache."""
        if key not in self.cache:
            self.cache[key] = []
        if isinstance(self.cache[key], list) and item not in self.cache[key]:
            self.cache[key].append(item)

    def list_del(self, key, item):
        """Remove an item from a list in the cache."""
        if key in self.cache and isinstance(self.cache[key], list):
            self.cache[key].remove(item)
            if not self.cache[key]:
                del self.cache[key]

    def set_dict_key(self, dict_key, sub_key, value):
        """Set a value inside a dictionary in the cache."""
        if dict_key not in self.cache:
            self.cache[dict_key] = {}
        if isinstance(self.cache[dict_key], dict):
            self.cache[dict_key][sub_key] = value

    def get_dict_key(self, dict_key, sub_key, default=None):
        """Retrieve a value from a dictionary in the cache."""
        return self.cache.get(dict_key, {}).get(sub_key, default)

    def del_dict_key(self, dict_key, sub_key):
        """Delete a key inside a dictionary in the cache."""
        if dict_key in self.cache and isinstance(self.cache[dict_key], dict):
            self.cache[dict_key].pop(sub_key, None)
            if not self.cache[dict_key]:
                del self.cache[dict_key]

    def tuple_add(self, key, item):
        """Add an item to a tuple in the cache."""
        if key not in self.cache:
            self.cache[key] = (item,)
        elif isinstance(self.cache[key], tuple) and item not in self.cache[key]:
            self.cache[key] += (item,)

    def tuple_del(self, key, item):
        """Remove an item from a tuple in the cache."""
        if key in self.cache and isinstance(self.cache[key], tuple):
            new_tuple = tuple(x for x in self.cache[key] if x != item)
            self.cache[key] = new_tuple
            if not new_tuple:
                del self.cache[key]

    def clear(self):
        """Clear the entire cache."""
        self.cache.clear()


def load_modules(directory: str):
    """
    Dynamically imports all Python files inside the given directory.
    """
    base_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
    module_dir = os.path.join(base_dir, directory)
    if not os.path.exists(module_dir):
        raise FileNotFoundError(
            f"Expected '{base_dir}/{directory}', but got '{module_dir}' instead."
        )

    for file in os.listdir(module_dir):
        if file.endswith(".py") and not file.startswith("__"):
            module_name = f"{module_dir}.{file[:-3]}"
            _c = "loaded_modules"
            try:
                importlib.import_module(module_name)

            except Exception as e:
                # debugging-purpose
                # pylint: disable=import-outside-toplevel
                import sys

                tb = traceback.format_exc()
                LOGS.error("Failed to load %s: %s\n%s", module_name, e, tb)
                sys.exit()


def is_dangerous(cmd: str) -> bool:
    """
    Used to determine wheter something is considered dangerous or not.

    This function is deisgned for internal use only, however, you can still use it.

    Args:
        cmd (:obj:`str`): The string to be analyzed.

    Returns:
        :obj:`bool`: `True` if it's dangerous.
    """
    # TODO
    return True
